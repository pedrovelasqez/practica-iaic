package jess;

import java.io.IOException;
import java.io.Serializable;
import java.io.Writer;
import java.util.*;

/** **********************************************************************
 * The working memory
 * <P>
 * (C) 2003 Ernest J. Friedman-Hill and Sandia National Laboratories<BR>
 * $Id: FactList.java,v 1.13.2.1 2003/09/14 12:29:21 ejfried Exp $
 */


class FactList implements Serializable {

    private Map m_table = Collections.synchronizedMap(new HashMap());
    private ArrayList m_factsToAssert = new ArrayList();
    private ArrayList m_factsToRetract = new ArrayList();
    private Map m_logicalSupport;

    private int m_time = 0;

    void clear() {
        m_table.clear();
        m_time = 0;
        m_factsToAssert.clear();
        m_factsToRetract.clear();
        if (m_logicalSupport != null)
            m_logicalSupport.clear();
        m_nextFactId = 0;
    }

    int getTime() {
        return m_time;
    }

    void assignTime(Fact fact) {
        fact.updateTime(++m_time);
    }

    int doPreAssertionProcessing(Fact f) {
        return m_table.containsKey(f) ? -1 : 0;
    }

    Fact findFactByFact(Fact f) {
        return (Fact) m_table.get(f);
    }

    Fact findFactByID(int id) {
        synchronized (m_table) {
            for (Iterator it = m_table.keySet().iterator(); it.hasNext();) {
                Fact f = (Fact) it.next();
                if (f.getFactId() == id)
                    return f;
            }
            return null;
        }
    }

    void ppFacts(String name, Writer output) throws IOException {
        for (Iterator e = listFacts(); e.hasNext();) {
            Fact f = (Fact) e.next();
            if (name == null || f.getName().equals(name)) {
                output.write(f.toString());
                output.write("\n");
            }
        }
    }

    void ppFacts(Writer output) throws IOException {
        ppFacts(null, output);
    }

    Iterator listFacts() {
        synchronized (m_table) {
            return new SortedIterator(m_table);
        }
    }

    /**
     * Successively incremented ID for asserted facts.
     */
    private Object m_idLock = new String("LOCK");
    private int m_nextFactId;

    private int nextFactId() {
        synchronized (m_idLock) {
            return m_nextFactId++;
        }
    }

    /**
     * Facts generated by LHS actions, not asserted until RHS time.
     */


    void setPendingFact(Fact fact, boolean assrt) {
        if (assrt)
            m_factsToAssert.add(fact);

        else {
            fact = (Fact) m_table.get(fact);
            if (fact != null)
                m_factsToRetract.add(fact);
        }
    }

    // Process any facts that were asserted by rule LHS processing --
    // i.e., for backwards chaining -- or should be retracted, for
    // instance, because logical support was removed.
    void processPendingFacts(Rete r) throws JessException {
        synchronized (m_factsToAssert) {
            while (m_factsToAssert.size() > 0) {
                Fact f = (Fact) m_factsToAssert.get(0);
                m_factsToAssert.remove(0);
                _assert(f, true, r, r.getGlobalContext());
            }
        }

        synchronized (m_factsToRetract) {
            while (m_factsToRetract.size() > 0) {
                Fact f = (Fact) m_factsToRetract.get(0);
                m_factsToRetract.remove(0);
                if (f.isShadow()) {
                    Object ov = f.getSlotValue("OBJECT").externalAddressValue(null);
                    r.undefinstanceNoRetract(ov);
                }
                _retract(f, r);
            }
        }
    }

    Fact assertFact(Fact f, Rete r, Context context)
            throws JessException {
        Fact fact = _assert(f, true, r, context);
        if (fact != null)
            processPendingFacts(r);
        return fact;
    }

    Fact assertKeepID(Fact f, Rete r, Context context) throws JessException {
        Fact fact = _assert(f, false, r, context);
        if (fact != null)
            processPendingFacts(r);
        return fact;
    }

    private Fact _assert(Fact f, boolean newID, Rete r, Context context)
            throws JessException {
        synchronized (m_table) {

             // find any old copy
            boolean alreadyExisted = (r.doPreAssertionProcessing(f) != 0);

            if (context.getLogicalSupportNode() != null) {
                Token token = context.getToken();
                context.getLogicalSupportNode().dependsOn(f, context.getToken());
                addLogicalSupportFor(token, f, alreadyExisted);
            } else if (m_logicalSupport != null) {
                addUnconditionalSupportFor(f);
            }

            if (alreadyExisted)
                return null;

            if (newID)
                f.setFactId(nextFactId());

            r.broadcastEvent(JessEvent.FACT, f);

            m_table.put(f, f);

            // Send it to the Rete network
            r.processToken(RU.ADD, f);

            return f;
        }
    }

    /**
     * Retract a fact.
     * @param f A Fact object. Doesn't need to be the actual object
     * that appears on the fact-list; can just be a Fact that could
     * compare equal to one.
     * @exception JessException If anything goes wrong.
     */

    Fact retract(Fact f, Rete r) throws JessException {
        synchronized (m_table) {
            Fact ff;
            if ((ff = (Fact) m_table.get(f)) != null) {
                _retract(ff, r);
                processPendingFacts(r);
            }
            return ff;
        }
    }

    // f should be the actual fact
    private Fact _retract(Fact f, Rete r) throws JessException {
        synchronized (m_table) {
            r.broadcastEvent(JessEvent.FACT | JessEvent.REMOVED, f);
            m_table.remove(f);
            removeAllLogicalSupportFor(f);
            r.processToken(RU.REMOVE, f);
            return f;
        }
    }

    Fact _duplicate(ValueVector vv, Context context, Rete r)
            throws JessException {

        Value fv = vv.get(1).resolveValue(context);
        Fact fact;
        int id;
        if (fv.type() == RU.INTEGER) {
            id = fv.intValue(context);
            fact = r.findFactByID(id);
        } else {
            fact = (Fact) fv.externalAddressValue(context);
            id = fact.getFactId();
        }

        if (fact == null || fact.getFactId() == -1)
            throw new JessException("duplicate", "no such fact", id);
        else if (fact.isShadow())
            throw new JessException("duplicate",
                    "Can't duplicate shadow fact",
                    fact.toString());

        Deftemplate dt = fact.getDeftemplate();

        synchronized (r.getCompiler()) {

            fact = (Fact) fact.clone();

            for (int i = 2; i < vv.size(); i++) {

                // fetch the slot, value subexp, stored as a List
                ValueVector svp = vv.get(i).listValue(context);
                String slotName = getSlotName(svp, context);
                int idx = dt.getSlotIndex(slotName);
                if (idx == -1)
                    throw new JessException("duplicate",
                            "No such slot " + slotName +
                            " in template",
                            dt.getName());
                int type = dt.getSlotType(idx);

                // Set the value in the fact
                fact.setSlotValue(slotName,
                        getSlotValue(svp, context, type));
            }
        }
        // Add the new fact to the Rete network
        return assertFact(fact, r, context);
    }

    Fact modify(Fact fact, String slot, Value value, Rete engine, Context context) throws JessException {
        if (fact.getShadowMode() == Fact.NO || fact.getShadowMode() == Fact.STATIC) {
            synchronized (engine.getActivationSemaphore()) {
                prepareToModify(fact, engine);
                fact.setSlotValue(slot, value);
                finishModify(fact, engine, context);
            }
        }

        if (fact.getShadowMode() != Fact.NO) {
            Value obj = fact.getSlotValue("OBJECT");
            Funcall fc = new Funcall("set", engine).arg(obj);
            fc.arg(new Value(slot, RU.ATOM));
            fc.arg(value);
            fc.execute(engine.getGlobalContext());
        }
        return fact;
    }

    Fact _modify(ValueVector vv, Context context, Rete r)
            throws JessException {

        Value fv = vv.get(1).resolveValue(context);
        Fact fact;
        int id;
        if (fv.type() == RU.INTEGER) {
            id = fv.intValue(context);
            fact = r.findFactByID(id);
        } else {
            fact = (Fact) fv.externalAddressValue(context);
            id = fact.getFactId();
        }
        if (fact == null || fact.getFactId() == -1)
            throw new JessException("modify", "no such fact", id);

        Deftemplate dt = fact.getDeftemplate();

        //////////////////////////////////////////////////
        // First find out of this is a shadow fact, not an ordinary fact
        // If so, call the appropriate mutators...
        //////////////////////////////////////////////////


        switch (fact.getShadowMode()) {

            case Fact.NO:
                fact = modifyRegularFact(r, fact, vv, context, dt);
                break;
            case Fact.DYNAMIC:
                fact = modifyShadowFact(r, fact, vv, context, dt);
                break;
            case Fact.STATIC:
                modifyShadowFact(r, fact, vv, context, dt);
                fact = modifyRegularFact(r, fact, vv, context, dt);
                break;
            default:
                throw new JessException("modify",
                        "Impossible shadow mode",
                        fact.getShadowMode());
        }

        return fact;

    }

    Fact prepareToModify(Fact fact, Rete engine)
            throws JessException {

        synchronized (engine.getCompiler()) {
            engine.processToken(RU.REMOVE, fact);
            fact = (Fact) m_table.remove(fact);
            removeAllLogicalSupportFor(fact);
            return fact;
        }
    }

    Fact finishModify(Fact fact, Rete engine, Context context)
            throws JessException {

        synchronized (engine.getCompiler()) {
            engine.broadcastEvent(JessEvent.FACT | JessEvent.MODIFIED, fact);
            if (context.getLogicalSupportNode() != null) {
                Token token = context.getToken();
                context.getLogicalSupportNode().dependsOn(fact, context.getToken());
                addLogicalSupportFor(token, fact, false);
            } else if (m_logicalSupport != null) {
                addUnconditionalSupportFor(fact);
            }
            if (engine.doPreAssertionProcessing(fact) == 0) {
                m_table.put(fact, fact);
                engine.processToken(RU.ADD, fact);

                processPendingFacts(engine);
                return fact;
            } else
                return Fact.getNullFact();
        }
    }

    private Fact modifyRegularFact(Rete engine, Fact fact, ValueVector vv,
                                   Context context, Deftemplate dt)
            throws JessException {

        synchronized (engine.getActivationSemaphore()) {
            fact = prepareToModify(fact, engine);

            try {
                for (int i = 2; i < vv.size(); i++) {

                    // fetch the slot, value subexp, stored as a List
                    ValueVector svp = vv.get(i).listValue(context);
                    String slotName = getSlotName(svp, context);
                    int idx = dt.getSlotIndex(slotName);
                    if (idx == -1)
                        throw new JessException("modify",
                                "No such slot " + slotName +
                                " in template",
                                dt.getName());
                    int type = dt.getSlotType(idx);

                    // Set the value in the fact
                    fact.setSlotValue(slotName, getSlotValue(svp, context, type));
                }

            } finally {
                fact = finishModify(fact, engine, context);
            }
        }
        return fact;
    }

    private Fact modifyShadowFact(Rete r, Fact fact, ValueVector vv,
                                  Context context, Deftemplate dt)
            throws JessException {

        Value ov = fact.getSlotValue("OBJECT");
        Funcall fc = new Funcall("set", r).arg(ov);
        fc.setLength(4);

        for (int i = 2; i < vv.size(); i++) {

            // fetch the slot, value subexp, stored as a List
            ValueVector svp = vv.get(i).listValue(context);
            String slotName = getSlotName(svp, context);

            fc.set(new Value(slotName, RU.ATOM), 2);
            int index = dt.getSlotIndex(slotName);
            if (index == -1)
                throw new JessException("modify",
                        "No such slot " + slotName +
                        " in template",
                        dt.getName());

            int type = dt.getSlotType(index);
            fc.set(getSlotValue(svp, context, type), 3);

            fc.execute(r.getGlobalContext());
        }


        return fact;
    }


    private String getSlotName(ValueVector svp, Context c)
            throws JessException {

        return svp.get(0).stringValue(c);
    }

    private Value getSlotValue(ValueVector svp, Context c, int type)
            throws JessException {

        if (type == RU.SLOT) {
            Value v = svp.get(1).resolveValue(c);
            while (v.type() == RU.LIST)
                v = v.listValue(c).get(0).resolveValue(c);

            return v;

        } else { // MULTISLOT
            ValueVector vv = new ValueVector();
            for (int i = 1; i < svp.size(); i++) {
                Value listItem = svp.get(i).resolveValue(c);
                if (listItem.type() == RU.LIST) {
                    ValueVector sublist = listItem.listValue(c);
                    for (int j = 0; j < sublist.size(); j++)
                        vv.add(sublist.get(j).resolveValue(c));
                } else
                    vv.add(listItem);
            }
            return new Value(vv, RU.LIST);
        }
    }

    void addLogicalSupportFor(Token token, Fact fact, boolean alreadyExisted) {
        if (m_logicalSupport == null)
            m_logicalSupport = Collections.synchronizedMap(new HashMap());
        ArrayList list = null;
        synchronized (m_logicalSupport) {
            list = (ArrayList) m_logicalSupport.get(fact);
            if (list == null) {
                if (alreadyExisted)
                    return;
                else {
                    list = new ArrayList();
                    m_logicalSupport.put(fact, list);
                }
            }
        }
        list.add(token);
    }

    /**
     * *If a fact is already dependent on something, then we need
     * to replace that support with the unconditional token.
     * Otherwise, we don't need to do anything.
     * @param fact
     */
    private void addUnconditionalSupportFor(Fact fact) {
        if (m_logicalSupport == null)
            return;

        synchronized (m_logicalSupport) {
            m_logicalSupport.remove(fact);
        }
    }

    /**
     * If all the support for a fact disappears, remove it.
     */

    void removeLogicalSupportFrom(Token token, Fact fact) {
        if (m_logicalSupport == null)
            return;
        ArrayList list = (ArrayList) m_logicalSupport.get(fact);
        if (list == null)
            return;
        synchronized (m_logicalSupport) {
            if (list.remove(token) && list.size() == 0) {
                m_logicalSupport.remove(fact);
                setPendingFact(fact, false);
            }
        }
    }

    ArrayList getSupportingTokens(Fact fact) {
        return (ArrayList) m_logicalSupport.get(fact);
    }

    void removeAllLogicalSupportFor(Fact f) {
        if (m_logicalSupport != null)
            m_logicalSupport.remove(f);
    }

    public ArrayList getSupportedFacts(Fact supporter) {
        ArrayList list = new ArrayList();
        synchronized (m_logicalSupport) {
            for (Iterator it = m_logicalSupport.entrySet().iterator(); it.hasNext();) {
                Map.Entry entry = (Map.Entry) it.next();
                ArrayList tokens = (ArrayList) entry.getValue();
                if (tokens == null)
                    continue;
                for (int i = 0; i < tokens.size(); ++i) {
                    Token token = (Token) tokens.get(i);
                    for (Token t = token; t != null; t = t.getParent()) {
                        if (t.topFact().getFactId() == supporter.getFactId())
                            list.add(entry.getKey());
                    }
                }
            }
        }
        return list;
    }

}

class FactComparator implements Comparator, Serializable {
    public int compare(Object o1, Object o2) {
        return ((Fact) o1).getFactId() - ((Fact) o2).getFactId();
    }
}

class SortedIterator implements Iterator, Serializable {
    private Object[] m_arr;
    private int m_index;

    SortedIterator(Map map) {
        m_arr = map.keySet().toArray();
        Arrays.sort(m_arr, new FactComparator());
    }

    public boolean hasNext() {
        return m_index < m_arr.length;
    }

    public Object next() {
        return m_arr[m_index++];
    }

    public void remove() throws UnsupportedOperationException {
        throw new UnsupportedOperationException();
    }
}



